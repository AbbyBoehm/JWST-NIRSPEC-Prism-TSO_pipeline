def s1_to_pipeline(s1_config):
    """Simple function to translate an s1_config dict to a Detector1Pipeline dict.

    Args:
        s1_config (dict): the config dictionary generated by the s1 .berry files.
    
    Returns:
        dict: a Detector1Pipeline dict.
    """
    s1_pipeline = {}
    for key in ("verbose","show_plots","save_plots"):
        s1_pipeline[key] = s1_config[key]

    # First, handle the complex ones with arguments.    
    s1_pipeline["saturation"] = {"skip":(not s1_config["do_saturation"]),
                                 "n_pix_grow_sat":s1_config["sat_growth"]}
    
    s1_pipeline["refpix"] = {"skip":(not s1_config["do_refpix"]),
                             "odd_even_columns":s1_config["odd_even_col"],
                             "use_side_ref_pixels":s1_config["use_side_ref"],
                             "side_smoothing_length":s1_config["side_smooth_len"],
                             "side_gain":s1_config["side_gain"],
                             "odd_even_rows":s1_config["odd_even_row"],
                             "ovr_corr_mitigation_ftr":s1_config["ovr_corr_mit"],
                             "preserve_irs2_refpix":s1_config["pres_irs2_ref"]}

    s1_pipeline["dark_current"] = {"skip":(not s1_config["do_dark_current"]),
                                   "dark_output":s1_config["dark_output"],
                                   "average_dark_current":s1_config["avg_dark"]}
    
    s1_pipeline["charge_migration"] = {"skip":(not s1_config["do_charge_mig"]),
                                       "signal_threshold":s1_config["signal_thres"]}
    
    s1_pipeline["jump"] = {"skip":(not s1_config["do_jump"]),
                           "rejection_threshold":s1_config["rej_threshold"],
                           "three_group_rejection_threshold":s1_config["three_group_rej"],
                           "four_group_rejection_threshold":s1_config["four_group_rej"],
                           "flag_4_neighbors":s1_config["flag_4"],
                           "max_jump_to_flag_neighbors":s1_config["max_jump"],
                           "min_jump_to_flag_neighbors":s1_config["min_jump"],
                           "maximum_cores":s1_config["max_cores"]}
    
    s1_pipeline["ramp_fit"] = {"skip":(not s1_config["do_ramp_fit"]),
                               "save_opt":s1_config["save_opt"],
                               "opt_name":s1_config["opt_name"],
                               "int_name":s1_config["int_name"],
                               "suppress_one_group":s1_config["suppress_one"],
                               "maximum_cores":s1_config["max_cores"]}
    
    # These next ones are fast because they have no args except for skip.
    for key in ("gain_scale","superbias","persistence","emicorr",
                "firstframe","lastframe","reset","rscd","group_scale",
                "dq_init","linearity"):
        s1_pipeline[key] = {"skip":(not s1_config["do_{}".format(key)])}

    return s1_pipeline

def s1_to_glbs(s1_config):
    """Simple function to translate an s1_config dict to a glbs dict.

    Args:
        s1_config (dict): the config dictionary generated by the s1 .berry files.
    
    Returns:
        dict: a glbs dict.
    """
    s1_glbs = {}
    for key in ("verbose","show_plots","save_plots"):
        s1_glbs[key] = s1_config[key]

    # glbs keys are nearly identical.
    for key in ("sigma","kernel","mask","rows"):
        s1_glbs[key] = s1_config["glbs_{}".format(key)]
    
    return s1_glbs

def s1_to_NSClean(s1_config):
    """Simple function to translate an s1_config dict to an NSClean dict.

    Args:
        s1_config (dict): the config dictionary generated by the s1 .berry files.
    
    Returns:
        dict: an NSClean dict.
    """
    s1_NSClean = {}
    
    return s1_NSClean

def s2_to_pipeline(s2_config):
    """Simple function to translate an s2_config dict to a Spec2Pipeline dict.

    Args:
        s2_config (dict): the config dictionary generated by the s2 .berry files.
    
    Returns:
        dict: a Spec2Pipeline dict.
    """
    s2_pipeline = {}

    for key in ("verbose","show_plots","save_plots"):
        s2_pipeline[key] = s2_config[key]

    # First, handle the complex ones with arguments.    
    s2_pipeline["assign_wcs"] = {"skip":(not s2_config["do_assign_wcs"]),
                                 "slit_y_low":s2_config["slit_y_low"],
                                 "slit_y_high":s2_config["slit_y_high"]}
    
    s2_pipeline["badpix_selfcal"] = {"skip":(not s2_config["do_selfcal"]),
                                     "flagfrac_lower":s2_config["flagfrac_lower"],
                                     "flagfrac_upper":s2_config["flagfrac_upper"],
                                     "kernel_size":s2_config["kernel_size"],
                                     "save_flagged":s2_config["save_flagged"]} 
    
    s2_pipeline["nsclean"] = {"skip":(not s2_config["do_jwstnsclean"]),
                              "mask_spectral_regions":s2_config["mask_trace"],
                              "n_sigma":s2_config["n_sigma"],
                              "save_mask":s2_config["save_mask"],
                              "user_mask":s2_config["user_mask"]}
    
    s2_pipeline["background"] = {"skip":(not s2_config["do_background"]),
                                 "sigma":s2_config["bkg_sigma"],
                                 "maxiters":s2_config["maxiters"],
                                 "save_combined_background":s2_config["save_bkg"],
                                 "wfss_mmag_extract":s2_config["wfss_mmag_bkg"]}
    
    s2_pipeline["extract_2d"] = {"skip":(not s2_config["do_extract_2d"]),
                                 "slit_name":s2_config["slit_name"],
                                 "tsgrism_extract_height":s2_config["tsgrism_height"],
                                 "wfss_extract_half_height":s2_config["wfss_halfheight"],
                                 "wfss_mmag_extract":s2_config["wfss_mmag_ext"],
                                 "wfss_nbright":s2_config["wfss_nbright"],
                                 "extract_orders":s2_config["extract_orders"],
                                 "grism_objects":s2_config["grism_objects"]}
    
    s2_pipeline["srctype"] = {"skip":(not s2_config["do_srctype"]),
                              "source_type":s2_config["source_type_st"]}
    
    s2_pipeline["master_background"] = {"skip":(not s2_config["do_master_bckg"]),
                                        "user_background":s2_config["user_bckg"],
                                        "save_background":s2_config["save_bckg"],
                                        "force_subtract":s2_config["force_subtract"],
                                        "output_use_model":s2_config["output_model"]}
    
    s2_pipeline["flat_field"] = {"skip":(not s2_config["do_flat_field"]),
                                 "save_interpolated_flat":s2_config["save_int_flat"],
                                 "user_supplied_flat":s2_config["user_flat"],
                                 "inverse":s2_config["inverse_ff"]}
    
    s2_pipeline["pathloss"] = {"skip":(not s2_config["do_pathloss"]),
                               "inverse":s2_config["inverse_pl"],
                               "source_type":s2_config["source_type_pl"],
                               "user_slit_loc":s2_config["user_slit_loc"]}
    
    s2_pipeline["barshadow"] = {"skip":(not s2_config["do_barshadow"]),
                                "inverse":s2_config["inverse_bar"],
                                "source_type":s2_config["source_type_bar"]}
    
    # FIX: hard-coding in all those post-JuniperS2 functions to be false.
    for step in ("photom","residual_fringe","pixel_replace","resample_spec",
                 "cube_build","extract_1d"):
        s2_pipeline[step] = {"skip":True}

    # These next ones are fast because they have no args except for skip.
    for key in ("msaflag","imprint","wavecorr","straylight",
                "fringe","wfss_contam"):
        s2_pipeline[key] = {"skip":(not s2_config["do_{}".format(key)])}

    return s2_pipeline

def s2_clean_dict(s2_pipeline, mode):
    """Removes unneeded tags from s2_pipeline based on observing mode.
    Allows for one universal s2_juniper.berry file to exist.

    Args:
        s2_pipeline (dict): instructions for running Spec2Pipeline.
        mode (str): the instrument used to make the observations.

    Returns:
        dict: s2_pipeline with extraneous tags popped.
    """
    # FIX: need to learn what keys are needed in other modes.
    if mode == 'NIRSPEC':
        bad_keys = ('badpix_selfcal','msaflag','imprint','background',
                    'master_background','straylight','fringe','barshadow',
                    'wfss_contam','residual_fringe','cube_build')
    elif mode == 'MIRI':
        bad_keys = ('msaflag','nsclean','imprint','extract_2d',
                    'master_background','wavecorr','pathloss','barshadow',
                    'wfss_contam','pixel_replace','resample_spec')
    for key in bad_keys:
        s2_pipeline.pop(key, None)
    return s2_pipeline

def make_planets(s5_config):
    """Reads out every planet inside the s5_config.

    Args:
        s5_config (dict): the config dictionary generated by the s5 .berry files.

    Returns:
        dict: dictionary of "planet1", "planet2", etc.
    """
    # Recall our special keys from read_config.
    special_keys = ["rp","fp","t_prim","t_seco","period",
                    "aor","incl","ecc","longitude"]
    prior_keys = [key+"_prior" for key in special_keys]
    for key in prior_keys:
        special_keys.append(key)

    # Now we are going to parse s5_config for individual planets.
    planets = {}
    total_planets = s5_config["n_planets"] # we have already told it how many planets we want to find.
    planet_N = 1 # we're going to step up planet_N until we run out of planets
    had_KeyError = False # haven't hit a key error
    while not had_KeyError:
        # Check to make sure we didn't read too much.
        if planet_N > total_planets:
            # If you wanted to read one planet and we're seeing two, we've gone too far.
            had_KeyError = True
        
        else:
            # Create a key for the Nth planet.
            planet_name = "planet{}".format(planet_N)
            # And a dictionary for that planet.
            planet = {}
            try:
                for key in special_keys:
                    planet[key+str(planet_N)] = s5_config[key+str(planet_N)] # as long as a planet of this number exists, s5_config will have this key
                
                # Now add the planet to the planets.
                planets[planet_name] = planet

                # And step up the planet number.
                planet_N += 1

            except KeyError:
                # We have run out of planet.
                had_KeyError = True

    return planets

def make_flares(s5_config):
    """Reads out every flare inside the s5_config.

    Args:
        s5_config (dict): the config dictionary generated by the s5 .berry files.

    Returns:
        dict: dictionary of "flare1", "flare2", etc.
    """
    # Recall our special keys from read_config.
    special_keys = ["A","B","C","Dr","Ds","Fr","E"]
    prior_keys = [key+"_prior" for key in special_keys]
    for key in prior_keys:
        special_keys.append(key)

    # Now we are going to parse s5_config for individual flares.
    flares = {}
    total_flares = s5_config["n_flares"]
    flare_ID = 1 # we're going to step up flare_ID until we run out of flares
    had_KeyError = False # haven't hit a key error
    while not had_KeyError:
        # Check to make sure we didn't read too much.
        if flare_ID > total_flares:
            # If you wanted to read one flare and we're seeing two, we've gone too far.
            had_KeyError = True
        
        else:
            # Create a key for the next flare.
            flare_name = "flare{}".format(flare_ID)
            # And a dictionary for that flare.
            flare = {}
            try:
                for key in special_keys:
                    flare[key+str(flare_ID)] = s5_config[key+str(flare_ID)] # as long as a flare of this number exists, s5_config will have this key

                # Now add the flare to the flares.
                flares[flare_name] = flare

                # And step up the flare ID number.
                flare_ID += 1

            except KeyError:
                # We have run out of flare.
                had_KeyError = True
        
    return flares

def make_systematics(s5_config, xpos, ypos, widths):
    """Reads out systematic instructions from the s5_config, inserting info as
    needed from the trace position.

    Args:
        s5_config (dict): the config dictionary generated by the s5 .berry files.
        xpos (np.array): dispersion position with time.
        ypos (np.array): cross-dispersion position with time.
        widths (np.array): cross-dispersion width with time.

    Returns:
        dict: dictionary of systematics instructions.
    """
    # We must manually initialize the coeffs for each model.
    systematics = {}
    systematics["poly"] = s5_config["poly"]
    if systematics["poly"]:
        # Then we need poly coeffs to match the requested order.
        n_coeffs = s5_config["poly_order"] + 1 # if you asked for a 0th order poly, you need 1 coefficient, etc.
        # The 0th degree term should be 1.
        coeffs = [1]
        for i in range(1, n_coeffs):
            # And initialize every term thereafter as 0.
            coeffs.append(0)
        systematics["poly_coeffs"] = coeffs
    
    systematics["mirrortilt"] = s5_config["mirrortilt"]
    if systematics["mirrortilt"]:
        # Then we need one mirror tilt pair per requested mirror tilt event.
        n_tilts = s5_config["n_tilt_events"]
        # The baseline flux should be initialized as 1.
        coeffs = [1]
        for i in range(0, n_tilts):
            # Every coeff for a tilt event is a pair: the time index at which
            # the tilt happened, and the step in flux after the tilt.
            coeffs.append([0,0])
        systematics["mirrortilt_coeffs"] = coeffs

    systematics["pos_detrend"] = s5_config["pos_detrend"]
    if systematics["pos_detrend"]:
        # Then we need the positions and detrending coefficients.
        systematics["xpos"] = xpos
        systematics["ypos"] = ypos
        systematics["widths"] = widths
        systematics["pos_detrend_coeffs"] = [0,0,0]
    
    systematics["singleramp"] = s5_config["singleramp"]
    if systematics["singleramp"]:
        # We need coefficients for a single exponential ramp.
        systematics["singleramp_coeffs"] = [0,0,0]

    systematics["doubleramp"] = s5_config["doubleramp"]
    if systematics["doubleramp"]:
        # We need coefficients for a double exponential ramp.
        systematics["doubleramp_coeffs"] = [0,0,0,0,0,0]

    # We're done parsing!
    return systematics

def make_LD(s5_config):
    """Reads out stellar limb darkening information from the s5_config.

    Args:
        s5_config (dict): the config dictionary generated by the s5 .berry files.

    Returns:
        dict: instructions for handling limb darkening.
    """
    # Define the LD keys.
    LD_keys = ["LD_model","fit_LDs","LD_initialguess","use_exotic","ld_data_path",
               "ld_grid","custom_grid","interpolate","instrument_mode"]
    
    # Copy that info out of s5_config.
    LD = {}
    for key in LD_keys:
        LD[key] = s5_config[key]

    # We also need the stellar info.
    stellar_params = {}
    for key in ("MH","Teff","logg"):
        stellar_params[key] = s5_config["star_"+key]
    LD["stellar_params"] = stellar_params

    return LD